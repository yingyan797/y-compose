<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Layer Drawing App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            margin: 0 auto;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .layer-controls, .grid-controls {
            background-color: #f8f8f8;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .canvas-container {
            position: relative;
            margin: 5px auto;
            border: 2px solid #333;
            background-color: white;
        }
        #drawingCanvas {
            cursor: crosshair;
            display: block;
        }
        .layers-panel {
            margin-top: 20px;
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 5px 0;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #eee;
        }
        .layer-item.active {
            background-color: #e6f7ff;
            border-color: #1890ff;
        }
        .color-display {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid #ccc;
        }
        .layer-name {
            flex-grow: 1;
        }
        .layer-visibility {
            margin-right: 10px;
        }
        button {
            background-color: cornflowerblue;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: lightseagreen;
        }
        button.remove-layer {
            background-color: salmon;
        }
        button.remove-layer:hover {
            color: #333;
        }
        input, select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .column {
            float: left;
            width: 50%;
        }

        /* Clear floats after the columns */
        .row:after {
            content: "";
            display: table;
            clear: both;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Multi-Layer Drawing App</h1>

        <div class="grid-controls">
            <label for="drawingMode">Mode: </label>
            <select id="drawingMode">
                <option value="discrete">Discrete (Grid)</option>
                <option value="continuous">Continuous (Free Draw)</option>
            </select>
            <label for="gridRows" id="gridControl">Grid Size: 
                <input type="number" id="gridRows" min="2" max="50" value="10" style="width: 50px;"> x 
                <input type="number" id="gridCols" min="2" max="50" value="10" style="width: 50px;">
                <button id="applyGridBtn">Set Grid</button>
                <button id="singleRangeBtn">Single cell</button>
            </label>
            <label id="canvasControl" style="display: none;">
                Brush/Eraser size: <input type="range" id="brushSize" min="1" max="100" value="10">
            </label> | 
            <button id="penEraser">Draw color</button>
        </div>
    <div class="row">
        <div class="column">

            <div class="canvas-container" style="width: 600px; height: 600px;">
                <canvas id="drawingCanvas" width="600" height="600"></canvas>
                <canvas id="gridOverlay" class="grid-overlay" width="600" height="600"></canvas>
            </div>
        </div><div class="column">

            <div class="layer-controls">
                <label for="newLayerName">New Layer: </label>
                <input type="text" id="newLayerName" placeholder="Layer name">
                <input type="color" id="newLayerColor" value="#ff0000">
                <button id="addLayerBtn">Add Layer</button>
            </div>
            <div class="layers-panel">
                <h3>Layers</h3>
                <div id="layersList"></div>
            </div>
        </div>
    </div>
    </div>

    <script>
        // App state
        const state = {
            mode: 'discrete',
            canvas: {
                width: 600,
                height: 600
            },
            grid: {
                rows: 10,
                cols: 10
            },
            layers: [
                { name: 'obstacle', color: '#000000', visible: true, data: {} },
                { name: 'goal-1', color: '#FF0000', visible: true, data: {} },
                { name: 'goal-2', color: '#00FF00', visible: true, data: {} },
                { name: 'goal-3', color: '#0000FF', visible: true, data: {} },
                { name: 'goal-4', color: '#FFFF00', visible: true, data: {} },
                { name: 'goal-5', color: '#FF00FF', visible: true, data: {} }
            ],
            activeLayerIndex: 0,
            isDrawing: false,
            lastPosition: null,
            lastCell: null
        };

        // DOM elements
        const gridControl = document.getElementById("gridControl");
        const canvasControl = document.getElementById("canvasControl");
        const penEraserBtn = document.getElementById("penEraser");
        const singleRangeBtn = document.getElementById("singleRangeBtn");
        const brushSize = document.getElementById("brushSize");

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const gridOverlay = document.getElementById('gridOverlay');
        const gridCtx = gridOverlay.getContext('2d');
        const modeSelect = document.getElementById('drawingMode');
        const gridRowsInput = document.getElementById('gridRows');
        const gridColsInput = document.getElementById('gridCols');
        const applyGridBtn = document.getElementById('applyGridBtn');
        const newLayerNameInput = document.getElementById('newLayerName');
        const newLayerColorInput = document.getElementById('newLayerColor');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const layersList = document.getElementById('layersList');

        // Initialize the app
        function init() {
            drawGrid();
            renderLayers();
            setupEventListeners();
            redrawCanvas();
        }

        // Draw grid on overlay
        function drawGrid() {
            gridCtx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            gridCtx.strokeStyle = '#cccccc';
            gridCtx.lineWidth = 1;
            
            const cellWidth = state.canvas.width / state.grid.cols;
            const cellHeight = state.canvas.height / state.grid.rows;
            
            // Draw vertical lines
            for (let x = 0; x <= state.canvas.width; x += cellWidth) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, state.canvas.height);
                gridCtx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= state.canvas.height; y += cellHeight) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(state.canvas.width, y);
                gridCtx.stroke();
            }
        }

        // Redraw the entire canvas based on all layers
        function redrawCanvas() {
            ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            
            // Draw all visible layers
            state.layers.forEach(layer => {
                if (!layer.visible) return;
                
                if (state.mode === 'discrete') {
                    // Draw grid cells
                    const cellWidth = state.canvas.width / state.grid.cols;
                    const cellHeight = state.canvas.height / state.grid.rows;
                    
                    ctx.fillStyle = layer.color;
                    
                    for (const key in layer.data) {
                        const [row, col] = key.split(',').map(Number);
                        ctx.fillRect(
                            col * cellWidth, 
                            row * cellHeight, 
                            cellWidth, 
                            cellHeight
                        );
                    }
                } else {
                    // Draw continuous paths
                    if (!layer.paths) return;
                    
                    ctx.strokeStyle = layer.color;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    
                    layer.paths.forEach(record => {
                        let path = record.path;
                        ctx.globalCompositeOperation = record.tool
                        ctx.lineWidth = record.lineWidth;
                        if (path.length < 2) return;
                        
                        ctx.beginPath();
                        ctx.moveTo(path[0].x, path[0].y);
                        
                        for (let i = 1; i < path.length; i++) {
                            ctx.lineTo(path[i].x, path[i].y);
                        }
                        
                        ctx.stroke();
                    });
                }
            });
        }

        // Render the layers list in the UI
        function renderLayers() {
            layersList.innerHTML = '';
            
            state.layers.forEach((layer, index) => {
                const layerItem = document.createElement('div');
                layerItem.className = `layer-item ${index === state.activeLayerIndex ? 'active' : ''}`;
                
                const colorDisplay = document.createElement('div');
                colorDisplay.className = 'color-display';
                colorDisplay.style.backgroundColor = layer.color;
                
                const visibilityCheckbox = document.createElement('input');
                visibilityCheckbox.type = 'checkbox';
                visibilityCheckbox.className = 'layer-visibility';
                visibilityCheckbox.checked = layer.visible;
                visibilityCheckbox.addEventListener('change', () => {
                    layer.visible = visibilityCheckbox.checked;
                    redrawCanvas();
                });
                
                const layerName = document.createElement('span');
                layerName.className = 'layer-name';
                layerName.textContent = layer.name;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-layer';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', () => removeLayer(index));
                
                layerItem.appendChild(colorDisplay);
                layerItem.appendChild(visibilityCheckbox);
                layerItem.appendChild(layerName);
                layerItem.appendChild(removeBtn);
                
                layerItem.addEventListener('click', (e) => {
                    if (e.target !== removeBtn && e.target !== visibilityCheckbox) {
                        setActiveLayer(index);
                    }
                });
                
                layersList.appendChild(layerItem);
            });
        }

        // Set the active layer
        function setActiveLayer(index) {
            state.activeLayerIndex = index;
            renderLayers();
        }

        // Add a new layer
        function addLayer(name, color) {
            if (!name.trim()) {
                alert('Please enter a layer name');
                return;
            }
            
            state.layers.push({
                name: name,
                color: color,
                visible: true,
                data: {}
            });
            
            state.activeLayerIndex = state.layers.length - 1;
            renderLayers();
        }

        // Remove a layer
        function removeLayer(index) {
            // Don't remove if it's the last layer
            if (state.layers.length <= 1) {
                alert('Cannot remove the last layer');
                return;
            }
            
            state.layers.splice(index, 1);
            
            // Update active layer index if needed
            if (state.activeLayerIndex >= state.layers.length) {
                state.activeLayerIndex = state.layers.length - 1;
            }
            
            renderLayers();
            redrawCanvas();
        }

        // Handle grid cell click in discrete mode
        function handleGridCellClick(x, y) {
            const cellWidth = state.canvas.width / state.grid.cols;
            const cellHeight = state.canvas.height / state.grid.rows;
            
            const col = Math.floor(x / cellWidth);
            const row = Math.floor(y / cellHeight);
            
            const activeLayer = state.layers[state.activeLayerIndex];
            const key = `${row},${col}`;

            if (singleRangeBtn.innerHTML[0] != "S"){
                if (!state.lastCell) {
                    state.lastCell = {row, col};
                } else {
                    const rf = Math.min(row, state.lastCell.row);
                    const rt = Math.max(row, state.lastCell.row);
                    const cf = Math.min(col, state.lastCell.col);
                    const ct = Math.max(col, state.lastCell.col);
                    const pen = penEraserBtn.innerHTML[0] == "D";
                    for (let r=rf; r <= rt; r++) {
                        for (let c=cf; c <= ct; c++) {
                            if (pen) {
                                activeLayer.data[`${r},${c}`] = true;
                            } else {
                                delete activeLayer.data[`${r},${c}`];
                            }
                        }
                    }
                    state.lastCell = null;
                }
            } else {
                if (activeLayer.data[key]) {
                    delete activeLayer.data[key];
                } else {
                    activeLayer.data[key] = true;
                }
            }
            
            redrawCanvas();
        }

        // Handle mouse movement in continuous mode
        function handleContinuousDraw(x, y) {
            if (!state.isDrawing) return;
            
            const activeLayer = state.layers[state.activeLayerIndex];
            
            if (!activeLayer.paths) {
                activeLayer.paths = [];
            }

            if (!state.currentPath) {
                state.currentPath = {path:[], tool:ctx.globalCompositeOperation, lineWidth:ctx.lineWidth };
                activeLayer.paths.push(state.currentPath);
            }
            
            state.currentPath.path.push({ x, y });
            ctx.strokeStyle = activeLayer.color;
            if (state.lastPosition) {
                ctx.beginPath();
                ctx.moveTo(state.lastPosition.x, state.lastPosition.y);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            
            state.lastPosition = { x, y };
        }

        // Setup event listeners
        function setupEventListeners() {
            // Mode change
            modeSelect.addEventListener('change', () => {
                state.mode = modeSelect.value;
                if (state.mode === 'discrete') {
                    gridOverlay.style.display = 'block';
                    gridControl.style.display = 'inline';
                    canvasControl.style.display = 'none';
                } else {
                    gridOverlay.style.display = 'none';
                    gridControl.style.display = 'none';
                    canvasControl.style.display = 'inline';
                }
                redrawCanvas();
            });
            
            // Apply grid
            applyGridBtn.addEventListener('click', () => {
                const rows = parseInt(gridRowsInput.value);
                const cols = parseInt(gridColsInput.value);
                
                if (rows >= 2 && rows <= 50 && cols >= 2 && cols <= 50) {
                    state.grid.rows = rows;
                    state.grid.cols = cols;
                    drawGrid();
                    redrawCanvas();
                } else {
                    alert('Grid size must be between 2 and 50');
                }
            });

            penEraserBtn.addEventListener('click', () => {
                if (penEraserBtn.innerHTML[0] == "D") {
                    penEraserBtn.innerHTML = "[Eraser]";
                } else {
                    penEraserBtn.innerHTML = "Draw color";
                }
            }); singleRangeBtn.addEventListener('click', () => {
                if (singleRangeBtn.innerHTML[0] != "S") {
                    singleRangeBtn.innerHTML = "Single cell";
                } else {
                    singleRangeBtn.innerHTML = "[Rectangle]";
                }
            })
            
            // Add layer
            addLayerBtn.addEventListener('click', () => {
                addLayer(newLayerNameInput.value, newLayerColorInput.value);
                newLayerNameInput.value = '';
            });
            
            // Canvas mouse events
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (state.mode === 'discrete') {
                    handleGridCellClick(x, y);
                } else {
                    state.isDrawing = true;
                    state.lastPosition = { x, y };
                    if (penEraserBtn.innerHTML[0] == "D") {
                        ctx.globalCompositeOperation = 'source-over';
                    } else {
                        ctx.globalCompositeOperation = 'destination-out';
                    }// Draw the line segment
                    ctx.lineWidth = brushSize.value;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    state.currentPath = {path:[{ x, y }], tool:ctx.globalCompositeOperation, lineWidth:ctx.lineWidth};
                    
                    const activeLayer = state.layers[state.activeLayerIndex];
                    if (!activeLayer.paths) {
                        activeLayer.paths = [];
                    }
                    activeLayer.paths.push(state.currentPath);
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (state.mode === 'continuous') {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    handleContinuousDraw(x, y);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                state.isDrawing = false;
                state.lastPosition = null;
                state.currentPath = null;
            });
            
            canvas.addEventListener('mouseleave', () => {
                state.isDrawing = false;
                state.lastPosition = null;
                state.currentPath = null;
            });
        }

        // Initialize application when document is loaded
        document.addEventListener('DOMContentLoaded', init);
        // Call init() to ensure app starts even if DOMContentLoaded already fired
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            init();
        }
    </script>
</body>
</html>