<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Y-Compose</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            margin: 0 auto;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .layer-controls, .grid-controls {
            background-color: #f8f8f8;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .canvas-container {
            position: relative;
            margin: 5px auto;
            border: 2px solid #333;
            background-color: white;
        }
        #drawingCanvas {
            cursor: crosshair;
            display: block;
        }
        .layers-panel {
            margin-top: 20px;
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 5px 0;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #eee;
        }
        .layer-item.active {
            background-color: #e6f7ff;
            border-color: #1890ff;
        }
        .color-display {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid #ccc;
        }
        .layer-name {
            flex-grow: 1;
        }
        .layer-visibility {
            margin-right: 10px;
        }
        button {
            background-color: cornflowerblue;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: blueviolet;
        }
        button.remove-layer {
            border: dashed;
            background-color: lightgoldenrodyellow;
            color: #333;
        }
        button.remove-layer:hover {
            color: salmon;
        }
        input, select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .column {
            float: left;
            width: 50%;
        }

        /* Clear floats after the columns */
        .row:after {
            content: "";
            display: table;
            clear: both;
        }
        .msg {
            font-size: small;
            color: lightseagreen;
            margin-left: 10px;
            padding: 3px;
            border-radius: 3px;
            border: dashed;
        }
        .clickable:hover {
            cursor: pointer;
            border: solid;
            color: blueviolet;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="grid-controls"><h3>Y-compose: terrain editing - 
            <input type="radio" name="drawingMode" value="discrete" checked><label id="modeD" style="color: blueviolet;"> Discrete (Grid) </label>
            <input type="radio" name="drawingMode" value="continuous"><label id="modeC">Continuous (Free Draw); </label>| 
            <a href="/ltl">LTL compose</a>; <i id="msgbox" class="msg" rows="1" readonly></i>
                <b id="cmsg" class="clickable" onclick="pushMessage(true, '')">X</b></h3>
            <label for="gridRows" id="gridControl">Grid Size: 
                <input type="number" id="gridRows" min="2" max="50" value="10" style="width: 50px;"> x 
                <input type="number" id="gridCols" min="2" max="50" value="10" style="width: 50px;">
                <button id="applyGridBtn">Set Grid</button>
                <button id="singleRangeBtn">Single cell</button>
            </label>
            <label id="canvasControl" style="display: none;">
                Brush size: <input type="range" id="brushSize" min="1" max="100" value="10" style="height: 4px;">
                <button id="undo"><-Undo</button>
                <button id="redo">Redo-></button>
            </label> | <button id="penEraser">Draw color</button> 
            <button class="remove-layer" id="clearLayer">Clear layer</button> 
            <button class="remove-layer" id="clear">Restart</button>
            Terrain name:<input type="file" style="width: 80px;" id="ipf" accept=".pt" oninput="uploadFile()"> 
            <input type="text" id="fname">.pt <button id="load">Load</button> <button id="save">Save</button>
            <button id="copy" style="border: dashed;" onclick="copyFile()">Copy</button> 
            <button id="delete" class="remove-layer">Delete</button> 
        </div>
    <div class="row">
        <div class="column">
            <div class="canvas-container" style="width: 600px; height: 600px;">
                <canvas id="drawingCanvas" width="600" height="600"></canvas>
                <canvas id="gridOverlay" class="grid-overlay" width="600" height="600"></canvas>
            </div>
        </div><div class="column">
            <div class="layer-controls">
                <label for="newLayerName">New Layer: </label>
                <input type="text" id="newLayerName" placeholder="Layer name">
                <input type="color" id="newLayerColor" value="#ff0000">
                <button id="addLayerBtn">Add Layer</button>
            </div>
            <div class="layers-panel">
                <h3>Layers to display ...</h3>
                <div id="layersList"></div>
            </div>
        </div>
    </div>
    </div>

    <script>
        // App state
        const state = {
            mode: 'discrete',
            canvas: {
                width: 600,
                height: 600
            },
            grid: {
                rows: 10,
                cols: 10
            },
            layers: [
                { name: 'obstacle', color: '#030303'},
                { name: 'goal-1', color: '#FF0000'},
                { name: 'goal-2', color: '#00FF00'},
                { name: 'goal-3', color: '#0000FF'},
                { name: 'goal-4', color: '#FFFF00'},
                { name: 'goal-5', color: '#FF00FF'}
            ],
            activeLayerIndex: 0,
            isDrawing: false,
            lastPosition: null,
            lastCell: null
        };
        state.layers.forEach((layer) => {
            layer.visible = true; 
            layer.data = {}; 
            let canvasLayer = document.createElement('canvas');
            canvasLayer.width = state.canvas.width;
            canvasLayer.height = state.canvas.height;
            layer.canvasLayer = canvasLayer;
            layer.ctxl = canvasLayer.getContext("2d");
        })

        // DOM elements
        const gridControl = document.getElementById("gridControl");
        const canvasControl = document.getElementById("canvasControl");
        const penEraserBtn = document.getElementById("penEraser");
        const singleRangeBtn = document.getElementById("singleRangeBtn");
        const brushSize = document.getElementById("brushSize");
        const undoBtn = document.getElementById("undo");
        const redoBtn = document.getElementById("redo");
        const clearBtn = document.getElementById("clear");
        const clearLayerBtn = document.getElementById("clearLayer");
        const fnameBox = document.getElementById("fname");
        const loadBtn = document.getElementById("load");
        const delBtn = document.getElementById("delete");
        const saveBtn = document.getElementById("save");
        const msgbox = document.getElementById("msgbox");

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const gridOverlay = document.getElementById('gridOverlay');
        const gridCtx = gridOverlay.getContext('2d');
        const modeSelect = document.getElementsByName('drawingMode');
        const modeD = document.getElementById('modeD');
        const modeC = document.getElementById('modeC');
        const gridRowsInput = document.getElementById('gridRows');
        const gridColsInput = document.getElementById('gridCols');
        const applyGridBtn = document.getElementById('applyGridBtn');
        const newLayerNameInput = document.getElementById('newLayerName');
        const newLayerColorInput = document.getElementById('newLayerColor');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const layersList = document.getElementById('layersList');

        // Initialize the app
        function init() {
            drawGrid();
            renderLayers();
            setupEventListeners();
            redrawCanvas();
        }
        function uploadFile() {
            const segs = document.getElementById("ipf").value.split("\\");
            fnameBox.value = segs[segs.length-1].split(".")[0];
        }
        function copyFile() {
            let text = "saved_disc";
            if (state.mode == "continuous") {
                text = "saved_cont";
            }
            text += "/"+fnameBox.value+".pt";
            navigator.clipboard.writeText(text);
            pushMessage(true, "Copied file path '"+text+"'")
        }
        function pushMessage(success, content) {
            if (success) {
                msgbox.style.color = "lightseagreen";
            } else {
                msgbox.style.color = "salmon";
            }
            msgbox.innerHTML = content;
        }

        // Draw grid on overlay
        function drawGrid() {
            gridCtx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            gridCtx.strokeStyle = '#cccccc';
            gridCtx.lineWidth = 1;
            
            const cellWidth = state.canvas.width / state.grid.cols;
            const cellHeight = state.canvas.height / state.grid.rows;
            
            // Draw vertical lines
            for (let x = 0; x <= state.canvas.width; x += cellWidth) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, state.canvas.height);
                gridCtx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= state.canvas.height; y += cellHeight) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(state.canvas.width, y);
                gridCtx.stroke();
            }
        }

        // Redraw the entire canvas based on all layers
        function redrawCanvas() {            
            // Draw all visible layers
            ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.layers.forEach(layer => {
                if (!layer.visible) return;
                
                if (state.mode === 'discrete') {
                    // Draw grid cells
                    const cellWidth = state.canvas.width / state.grid.cols;
                    const cellHeight = state.canvas.height / state.grid.rows;
                    
                    ctx.fillStyle = layer.color;
                    
                    for (const key in layer.data) {
                        const [row, col] = key.split(',').map(Number);
                        ctx.fillRect(
                            col * cellWidth, 
                            row * cellHeight, 
                            cellWidth, 
                            cellHeight
                        );
                    }
                } else {
                    // Draw continuous paths
                    // if (!layer.paths) return;
                    // let canvasLayer = document.createElement('canvas');
                    // canvasLayer.width = state.canvas.width;
                    // canvasLayer.height = state.canvas.height;
                    // const ctxl = canvasLayer.getContext("2d");
                    // ctxl.strokeStyle = layer.color;
                    // ctxl.lineJoin = 'round';
                    // ctxl.lineCap = 'round';
                    
                    // layer.paths.forEach(record => {
                    //     let path = record.path;
                    //     ctxl.globalCompositeOperation = record.tool
                    //     ctxl.lineWidth = record.lineWidth;
                    //     if (path.length < 2) return;
                        
                    //     ctxl.beginPath();
                    //     ctxl.moveTo(path[0].x, path[0].y);
                        
                    //     for (let i = 1; i < path.length; i++) {
                    //         ctxl.lineTo(path[i].x, path[i].y);
                    //     }
                        
                    //     ctxl.stroke();
                    // });

                    ctx.drawImage(layer.canvasLayer, 0, 0, state.canvas.width, state.canvas.height);
                }
            });
        }

        // Render the layers list in the UI
        function renderLayers() {
            layersList.innerHTML = '';
            
            state.layers.forEach((layer, index) => {
                const layerItem = document.createElement('div');
                layerItem.className = `layer-item ${index === state.activeLayerIndex ? 'active' : ''}`;
                
                const colorDisplay = document.createElement('div');
                colorDisplay.className = 'color-display';
                colorDisplay.style.backgroundColor = layer.color;
                
                const visibilityCheckbox = document.createElement('input');
                visibilityCheckbox.type = 'checkbox';
                visibilityCheckbox.className = 'layer-visibility';
                visibilityCheckbox.checked = layer.visible;
                visibilityCheckbox.addEventListener('change', () => {
                    layer.visible = visibilityCheckbox.checked;
                    redrawCanvas();
                });
                
                const layerName = document.createElement('span');
                layerName.className = 'layer-name';
                layerName.textContent = layer.name;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-layer';
                removeBtn.textContent = 'Remove';
                removeBtn.disabled = true;
                removeBtn.addEventListener('click', () => removeLayer(index));
                
                layerItem.appendChild(colorDisplay);
                layerItem.appendChild(visibilityCheckbox);
                layerItem.appendChild(layerName);
                layerItem.appendChild(removeBtn);
                
                layerItem.addEventListener('click', (e) => {
                    if (e.target !== removeBtn && e.target !== visibilityCheckbox) {
                        setActiveLayer(index);
                    }
                });
                
                layersList.appendChild(layerItem);
            });
        }

        // Set the active layer
        function setActiveLayer(index) {
            state.activeLayerIndex = index;
            renderLayers();
        }

        // Add a new layer
        function addLayer(name, color) {
            if (!name.trim()) {
                alert('Please enter a layer name');
                return;
            }
            
            state.layers.push({
                name: name,
                color: color,
                visible: true,
                data: {},
            });
            
            state.activeLayerIndex = state.layers.length - 1;
            renderLayers();
        }

        // Remove a layer
        function removeLayer(index) {
            // Don't remove if it's the last layer
            if (state.layers.length <= 1) {
                alert('Cannot remove the last layer');
                return;
            }
            
            state.layers.splice(index, 1);
            
            // Update active layer index if needed
            if (state.activeLayerIndex >= state.layers.length) {
                state.activeLayerIndex = state.layers.length - 1;
            }
            
            renderLayers();
            redrawCanvas();
        }

        // Handle grid cell click in discrete mode
        function handleGridCellClick(x, y) {
            const cellWidth = state.canvas.width / state.grid.cols;
            const cellHeight = state.canvas.height / state.grid.rows;
            
            const col = Math.floor(x / cellWidth);
            const row = Math.floor(y / cellHeight);
            
            const activeLayer = state.layers[state.activeLayerIndex];
            const key = `${row},${col}`;

            if (singleRangeBtn.innerHTML[0] != "S"){
                if (!state.lastCell) {
                    state.lastCell = {row, col};
                } else {
                    const rf = Math.min(row, state.lastCell.row);
                    const rt = Math.max(row, state.lastCell.row);
                    const cf = Math.min(col, state.lastCell.col);
                    const ct = Math.max(col, state.lastCell.col);
                    const pen = penEraserBtn.innerHTML[0] == "D";
                    for (let r=rf; r <= rt; r++) {
                        for (let c=cf; c <= ct; c++) {
                            if (pen) {
                                activeLayer.data[`${r},${c}`] = true;
                            } else {
                                delete activeLayer.data[`${r},${c}`];
                            }
                        }
                    }
                    state.lastCell = null;
                }
            } else {
                if (activeLayer.data[key]) {
                    delete activeLayer.data[key];
                } else {
                    activeLayer.data[key] = true;
                }
            }
            
            redrawCanvas();
        }

        // Handle mouse movement in continuous mode
        function handleContinuousDraw(x, y) {
            if (!state.isDrawing) return;
            
            const activeLayer = state.layers[state.activeLayerIndex];
            if (!activeLayer.paths) {
                activeLayer.paths = [];
            }

            if (!state.currentPath) {
                state.currentPath = {path:[], tool:ctx.globalCompositeOperation, lineWidth:ctx.lineWidth };
                activeLayer.paths.push(state.currentPath);
            }
            
            state.currentPath.path.push({ x, y });
            const ctxl = activeLayer.ctxl;
            ctxl.strokeStyle = activeLayer.color;
            if (state.lastPosition) {
                ctxl.beginPath();
                ctxl.moveTo(state.lastPosition.x, state.lastPosition.y);
                ctxl.lineTo(x, y);
                ctxl.stroke();
            }
            state.lastPosition = { x, y };
            ctx.drawImage(activeLayer.canvasLayer, 0, 0, state.canvas.width, state.canvas.height);
        }

        function setupGrid(rows, cols) {
            if (rows >= 2 && rows <= 50 && cols >= 2 && cols <= 50) {
                state.grid.rows = rows;
                state.grid.cols = cols;
                drawGrid();
                redrawCanvas();
            } else {
                alert('Grid size must be between 2 and 50');
            }
        }

// Setup event listeners
        function setupEventListeners() {
            // Mode change
            modeSelect.forEach((mode) => {mode.addEventListener('click', () => {
                state.mode = mode.value;
                if (state.mode === 'discrete') {
                    gridOverlay.style.display = 'block';
                    gridControl.style.display = 'inline';
                    canvasControl.style.display = 'none';
                    modeD.style.color = "blueviolet";
                    modeC.style.color = "black";
                } else {
                    gridOverlay.style.display = 'none';
                    gridControl.style.display = 'none';
                    canvasControl.style.display = 'inline';
                    modeC.style.color = "blueviolet";
                    modeD.style.color = "black";
                }
                redrawCanvas();
            })});
            
            // Apply grid
            applyGridBtn.addEventListener('click', () => {
                const rows = parseInt(gridRowsInput.value);
                const cols = parseInt(gridColsInput.value);
                setupGrid(rows, cols);
            });

            penEraserBtn.addEventListener('click', () => {
                if (penEraserBtn.innerHTML[0] == "D") {
                    penEraserBtn.innerHTML = "[Eraser]";
                    penEraserBtn.style.color = "lightgreen";
                } else {
                    penEraserBtn.innerHTML = "Draw color";
                    penEraserBtn.style.color = "white";
                }
            }); singleRangeBtn.addEventListener('click', () => {
                if (singleRangeBtn.innerHTML[0] != "S") {
                    singleRangeBtn.innerHTML = "Single cell";
                    singleRangeBtn.style.color = "white";
                } else {
                    singleRangeBtn.innerHTML = "[Rectangle]";
                    singleRangeBtn.style.color = "lightgreen";
                }
            })

            undoBtn.addEventListener('click', () => {
                const activeLayer = state.layers[state.activeLayerIndex];
                if (!activeLayer.paths) {
                    activeLayer.paths = [];
                    activeLayer.backups = [];
                } else if (activeLayer.paths.length > 0) {
                    activeLayer.backups.push(activeLayer.paths.pop());
                    redrawCanvas();
                }
            })
            redoBtn.addEventListener('click', () => {
                const activeLayer = state.layers[state.activeLayerIndex];
                if (!activeLayer.backups) {
                    activeLayer.backups = [];
                } else if (activeLayer.backups.length > 0) {
                    activeLayer.paths.push(activeLayer.backups.pop());
                    redrawCanvas();
                }
            })
            clearBtn.addEventListener('click', () => {
                if (state.mode == "discrete") {
                    state.layers.forEach((layer) => {
                        layer.data = {};
                    })
                    redrawCanvas();
                } else {
                    state.layers.forEach((layer) => {
                        layer.ctxl.clearRect(0, 0, state.canvas.width, state.canvas.height);
                    })
                    ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
                }
            }); clearLayerBtn.addEventListener('click', () => {
                const activeLayer = state.layers[state.activeLayerIndex]; 
                if (state.mode == "discrete") {
                    activeLayer.data = {};
                    redrawCanvas();
                } else {
                    activeLayer.ctxl.clearRect(0, 0, state.canvas.width, state.canvas.height);
                    redrawCanvas();
                }
            })

            loadBtn.addEventListener('click', () => {
                if (state.mode == "continuous") {
                    fetch('/get_images', {method:'POST', headers: {
                            'Content-Type': 'application/json'
                        },body: JSON.stringify({fname: fnameBox.value+".pt"})})
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {                    
                        if (!data.success) {
                            pushMessage(false, "Not found images "+fnameBox.value);
                            return;
                        }
                        data.images.forEach((image, i) => {
                            if (state.layers[i].name == image.name) {
                                if (!image.hasimage) {return};
                                const img = new Image();
                                const ctxl = state.layers[i].ctxl;
                                img.onload = function() {
                                    ctxl.drawImage(img, 0, 0, state.canvas.width, state.canvas.height)
                                };
                                img.src = `data:image/png;base64,${image.image}`;
                            } else {
                                console.log("index error");
                            }
                        })
                        pushMessage(true, "Loading images "+fnameBox.value);
                    })
                } else {
                    fetch("/load_grid", {method:'POST', 
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body:JSON.stringify({fname:fnameBox.value+".pt"})})
                    .then(response => response.json()).then(data => {
                        if (!data.success) {
                            pushMessage(false, "Not found grid "+fnameBox.value);
                            return;
                        }
                        data.grid.forEach((layer, i) => {
                            if (layer.name == state.layers[i].name) {
                                state.layers[i].data = layer.data;
                            }
                        })
                        setupGrid(data.rows, data.cols);
                        gridRowsInput.value = data.rows;
                        gridColsInput.value = data.cols;
                        pushMessage(true, "Loading grid "+fnameBox.value);
                    })
                }
            })
            saveBtn.addEventListener('click', () => {
                if (state.mode == "continuous") {
                    const requestBody = {fname:fnameBox.value+".pt", dim: [state.canvas.height, state.canvas.width]}; 
                    const terrain = [];

                    state.layers.forEach((layer) => {
                        const imageData = layer.canvasLayer.toDataURL('image/png').replace(/^data:image\/png;base64,/, '');
                        terrain.push({name: layer.name, color: layer.color, mask: imageData})
                    })
                    
                    // Create request body
                    requestBody["terrain"] = terrain;
                    
                    // Send POST request to Flask endpoint
                    return fetch('/save_images', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Error saving image ${imageId}: ${response.statusText}`);
                        }
                        return response.json();
                    }).then(data => {
                        if (!data.success) {
                            pushMessage(false, "Failed to save "+fnameBox.value);
                        } else {
                            pushMessage(true, "Saving images "+fnameBox.value);
                        }
                    });
                } else {
                    const requestBody = {fname:fnameBox.value+".pt", dim: [state.grid.rows, state.grid.cols]};
                    requestBody["terrain"] = state.layers.map((layer) => {
                        return {name: layer.name, color: layer.color, mask: layer.data};
                    });
                    fetch('/save_grid', {method: 'POST', 
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)})
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Error saving grid ${response.statusText}`);
                        }
                        return response.json();
                    }).then(data => {
                        if (!data.success) {
                            pushMessage(false, "Failed to save "+fnameBox.value);
                        } else {
                            pushMessage(true, "Saving grids "+fnameBox.value);
                        }
                    });;
                }
                pushMessage(true, "Save file "+fnameBox.value);
            })
            delBtn.addEventListener('click', () => {
                let mode = "saved_disc";
                if (state.mode == "continuous") {
                    mode = "saved_cont";
                }
                fetch('/deltrn/'+mode, {method:'PUT', 
                headers: {
                            'Content-Type': 'application/json'
                        },body:JSON.stringify({fname:fnameBox.value+".pt"})})
                .then(response => response.json()).then( data => {
                    if (data.success) {
                        pushMessage(true, "Delete "+mode+"/"+fnameBox.value);
                    } else {
                        pushMessage(false, "Delete file not found");
                    }
                })
            })
            
            // Add layer
            addLayerBtn.addEventListener('click', () => {
                addLayer(newLayerNameInput.value, newLayerColorInput.value);
                newLayerNameInput.value = '';
            });
            
            // Canvas mouse events
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (state.mode === 'discrete') {
                    handleGridCellClick(x, y);
                } else {
                    state.isDrawing = true;
                    state.lastPosition = { x, y };
                    
                    state.currentPath = {path:[{ x, y }], tool:ctx.globalCompositeOperation, lineWidth:ctx.lineWidth};
                    
                    const activeLayer = state.layers[state.activeLayerIndex];
                    const ctxl = activeLayer.ctxl;
                    if (penEraserBtn.innerHTML[0] == "D") {
                        ctxl.globalCompositeOperation = 'source-over';
                    } else {
                        ctxl.globalCompositeOperation = 'destination-out';
                    }// Draw the line segment
                    ctxl.lineWidth = brushSize.value;
                    ctxl.lineJoin = 'round';
                    ctxl.lineCap = 'round';
                    if (!activeLayer.paths) {
                        activeLayer.paths = [];
                    }
                    activeLayer.paths.push(state.currentPath);
                    activeLayer.backups = [];

                    ctx.beginPath();
                    ctx.arc(x, y, brushSize.value/2, 0, Math.PI * 2);
                    ctx.strokeStyle = activeLayer.color;
                    ctx.stroke();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (state.mode === 'continuous') {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    if (state.isDrawing) {
                        // Draw the brush radius indicator (outline circle)
                        ctx.beginPath();
                        ctx.arc(x, y, brushSize.value/2, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0.8, 0.8, 0.8, 0.2)';
                        ctx.stroke();
                    }
                    handleContinuousDraw(x, y);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                state.isDrawing = false;
                state.lastPosition = null;
                state.currentPath = null;
                redrawCanvas();
            });
            
            canvas.addEventListener('mouseleave', () => {
                state.isDrawing = false;
                state.lastPosition = null;
                state.currentPath = null;
                redrawCanvas();
            });
        }

        // Initialize application when document is loaded
        document.addEventListener('DOMContentLoaded', init);
        // Call init() to ensure app starts even if DOMContentLoaded already fired
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            init();
        }
    </script>
</body>
</html>