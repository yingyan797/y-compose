<!DOCTYPE html>
<html lang="en">

{% extends "layout.html" %}

{% block content %}
            
            // Toggle selection mode
            singleSelectButton.addEventListener('click', function() {
                isRangeSelectionMode = false;
                singleSelectButton.classList.add('active');
                rangeSelectButton.classList.remove('active');
                rangeStart = null;
            });
            
            rangeSelectButton.addEventListener('click', function() {
                isRangeSelectionMode = true;
                rangeSelectButton.classList.add('active');
                singleSelectButton.classList.remove('active');
                rangeStart = null;
            });
            
            
            // Load cell selections into the grid
            function loadCellSelections(cells) {
                selectedCells = [];
                
                // Clear existing selections
                document.querySelectorAll('.cell').forEach(cell => {
                    Object.keys(cellTypes).forEach(typeKey => {
                        cell.classList.remove(typeKey);
                    });
                    
                    const labelsContainer = cell.querySelector('.cell-labels');
                    if (labelsContainer) {
                        labelsContainer.innerHTML = '';
                    }
                });
                
                // Apply loaded selections
                cells.forEach(cellData => {
                    const cell = document.querySelector(`.cell[data-row="${cellData.row}"][data-col="${cellData.col}"]`);
                    if (cell) {
                        addCellType(cell, cellData.row, cellData.col, cellData.type);
                    }
                });
            }
            
            // Remove a cell type from all cells
            function removeCellTypeFromAllCells(typeKey) {
                // Remove class from all cells
                document.querySelectorAll(`.cell.${typeKey}`).forEach(cell => {
                    cell.classList.remove(typeKey);
                });
                
                // Remove from selected cells data
                selectedCells = selectedCells.filter(cell => cell.type !== typeKey);
                
                // Remove labels
                document.querySelectorAll('.cell').forEach(cell => {
                    updateCellLabels(cell);
                });
            }
            
            // Create a new grid with given size
            function createTerrain(rows, cols) {
                // Clear existing grid
                gridContainer.innerHTML = '';
                selectedCells = [];
                
                // Set grid template
                gridContainer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                gridContainer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
                
                // Create cells
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.title = `r=${row},c=${col}`;
                        
                        // Create container for labels
                        const labelsContainer = document.createElement('div');
                        labelsContainer.className = 'cell-labels';
                        cell.appendChild(labelsContainer);
                        
                        // Handle cell click event
                        cell.addEventListener('click', function() {
                            const cellRow = parseInt(this.dataset.row);
                            const cellCol = parseInt(this.dataset.col);
                            
                            if (isRangeSelectionMode) {
                                // Range selection mode
                                if (rangeStart === null) {
                                    // First click - set start point
                                    rangeStart = { row: cellRow, col: cellCol };
                                    this.classList.add('range-start');
                                } else {
                                    // Second click - select the range
                                    const startRow = Math.min(rangeStart.row, cellRow);
                                    const endRow = Math.max(rangeStart.row, cellRow);
                                    const startCol = Math.min(rangeStart.col, cellCol);
                                    const endCol = Math.max(rangeStart.col, cellCol);
                                    
                                    // Apply selection to all cells in range
                                    selectRange(startRow, endRow, startCol, endCol);
                                    
                                    // Remove range start indicator
                                    document.querySelectorAll('.cell.range-start').forEach(cell => {
                                        cell.classList.remove('range-start');
                                    });
                                    
                                    // Reset for next range selection
                                    rangeStart = null;
                                }
                            } else {
                                // Single selection mode
                                handleCellSelection(this, cellRow, cellCol);
                            }
                        });
                        
                        gridContainer.appendChild(cell);
                    }
                }
            }
            
            // Handle cell selection based on current mode
            function handleCellSelection(cellElement, row, col) {
                if (isAddTypeMode) {
                    addCellType(cellElement, row, col, currentCellType);
                } else {
                    removeCellType(cellElement, row, col, currentCellType);
                }
            }
            
            // Add a type to a cell
            function addCellType(cellElement, row, col, typeKey) {
                // Check if this cell already has this type
                const existingIndex = selectedCells.findIndex(c => 
                    c.row === row && c.col === col && c.type === typeKey);
                
                if (existingIndex < 0) {
                    // Add class to cell
                    cellElement.classList.add(typeKey);
                    
                    // Add to selected cells
                    selectedCells.push({
                        row: row,
                        col: col,
                        type: typeKey
                    });
                    
                    // Update labels
                    updateCellLabels(cellElement);
                }
            }
            
            // Remove a type from a cell
            function removeCellType(cellElement, row, col, typeKey) {
                // Find this cell type
                const existingIndex = selectedCells.findIndex(c => 
                    c.row === row && c.col === col && c.type === typeKey);
                
                if (existingIndex >= 0) {
                    // Remove class from cell
                    cellElement.classList.remove(typeKey);
                    
                    // Remove from selected cells
                    selectedCells.splice(existingIndex, 1);
                    
                    // Update labels
                    updateCellLabels(cellElement);
                }
            }
            
            // Update labels on a cell
            function updateCellLabels(cellElement) {
                const row = parseInt(cellElement.dataset.row);
                const col = parseInt(cellElement.dataset.col);
                const labelsContainer = cellElement.querySelector('.cell-labels');
                
                // Clear existing labels
                labelsContainer.innerHTML = '';
                
                // Get all types for this cell
                const cellTypesData = selectedCells.filter(c => c.row === row && c.col === col);
                
                // Create a label for each type
                cellTypesData.forEach(cellData => {
                    const typeInfo = cellTypes[cellData.type];
                    let typeIndex = Object.keys(cellTypes).indexOf(cellData.type);
                    if (typeIndex > 5) {
                        typeIndex = typeInfo.name.substr(0, 2);
                    }
                    if (typeInfo) {
                        const label = document.createElement('span');
                        label.className = 'cell-label';
                        label.textContent = typeIndex;
                        label.style.backgroundColor = typeInfo.color;
                        label.style.color = getContrastColor(typeInfo.color);
                        labelsContainer.appendChild(label);
                    }
                });
            }
            
            // Get a contrasting text color (black or white) based on background color
            function getContrastColor(hexColor) {
                // Convert hex to RGB
                const r = parseInt(hexColor.substr(1, 2), 16);
                const g = parseInt(hexColor.substr(3, 2), 16);
                const b = parseInt(hexColor.substr(5, 2), 16);
                
                // Calculate luminance
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                // Return black for light colors, white for dark colors
                return luminance > 0.5 ? '#000000' : '#FFFFFF';
            }
            
            // Select a range of cells
            function selectRange(startRow, endRow, startCol, endCol) {
                // Apply selection to each cell in the range
                for (let row = startRow; row <= endRow; row++) {
                    for (let col = startCol; col <= endCol; col++) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            if (isAddTypeMode) {
                                addCellType(cell, row, col, currentCellType);
                            } else {
                                removeCellType(cell, row, col, currentCellType);
                            }
                        }
                    }
                }
            }
            
            // Save selection to the backend
            saveSelectionButton.addEventListener('click', function() {
                const formData = new FormData();
                formData.append('grid_rows', gridRowsInput.value);
                formData.append('grid_cols', gridColsInput.value);
                formData.append('grid_name', gridNameInput.value || 'Untitled Grid');
                formData.append('copy', document.getElementById("save-copy").checked);
                formData.append('grid_id', savedGridsSelect.value);
                formData.append('selected_cells', JSON.stringify(selectedCells));
                formData.append('cell_types', JSON.stringify(cellTypes));
                
                fetch('/save_grid', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Grid selection saved successfully!');
                        if (data.grid_id) {
                            // If this is a new grid, add it to the dropdown
                            const entry = savedGridsSelect.querySelector(`option[value="${data.grid_id}"]`);
                            if (!entry) {
                                const option = document.createElement('option');
                                option.value = data.grid_id;
                                option.textContent = `${gridNameInput.value || 'Untitled Grid'} (${gridRowsInput.value}×${gridColsInput.value})`;
                                savedGridsSelect.appendChild(option);
                                fileName.innerHTML = "'"+data.grid_id+".json'";
                            } else {
                                entry.innerHTML = data.grid_name + " (" + data.grid_rows + "×" +data.grid_cols + ")";
                            }
                        }
                        if (data.redirect) {
                            window.location.href = data.redirect;
                        }
                    } else {
                        alert('Error saving grid selection: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while saving.');
                });
            });
            
            // Clear all selections
            clearSelectionButton.addEventListener('click', function() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    // Remove all type classes
                    Object.keys(cellTypes).forEach(typeKey => {
                        cell.classList.remove(typeKey);
                    });
                    
                    // Clear labels
                    const labelsContainer = cell.querySelector('.cell-labels');
                    if (labelsContainer) {
                        labelsContainer.innerHTML = '';
                    }
                });
                
                selectedCells = [];
                rangeStart = null;
            });
            
            

{% endblock %}
</html>