<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Selection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #333;
        }
        
        .grid-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        .grid {
            border: 2px solid #333;
            display: inline-grid;
        }
        
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .cell.obstacle {
            background-color: #333;
            color: white;
        }
        
        .cell.goal-1 {
            background-color: #2196F3;
            color: white;
        }
        
        .cell.goal-2 {
            background-color: #FF9800;
            color: white;
        }
        
        .cell.goal-3 {
            background-color: #9C27B0;
            color: white;
        }
        
        .cell.goal-4 {
            background-color: #E91E63;
            color: white;
        }
        
        .cell.goal-5 {
            background-color: #00BCD4;
            color: white;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .selection-mode {
            margin: 0 10px;
        }
        
        .cell-type-selector {
            margin: 0 10px;
        }
        
        button {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button.active {
            background-color: #2E7D32;
            outline: 2px solid skyblue;
        }
        
        .size-input {
            width: 50px;
            padding: 5px;
            margin: 0 5px;
        }
        
        .cell-labels {
            position: absolute;
            top: 0;
            right: 0;
            left: 0;
            bottom: 0;
            pointer-events: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
            align-content: flex-start;
            padding: 2px;
        }
        
        .cell-label {
            font-size: 8px;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            color: #000;
            border-radius: 3px;
            padding: 1px 2px;
            margin: 1px;
        }

        .custom-type-creator {
            display: flex;
            align-items: center;
            margin: 10px;
        }

        .custom-type-creator input {
            padding: 5px;
            margin-right: 5px;
        }

        .color-picker {
            margin: 0 5px;
        }

        .type-action-mode {
            margin: 0 10px;
        }

        .cell-types-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin: 10px 0;
        }

        .cell-type-tag {
            display: inline-flex;
            align-items: center;
            background-color: #f0f0f0;
            border-radius: 15px;
            padding: 5px 10px;
            margin: 3px;
            font-size: 12px;
            cursor: pointer;
        }

        .cell-type-tag.active {
            outline: 2px solid #1B5E20;
        }

        .cell-type-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .cell-type-delete {
            margin-left: 5px;
            color: #f44336;
            font-weight: bold;
            cursor: pointer;
        }

        .type-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            top: 0;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .grid-selection {
            margin: 20px 0;
            text-align: center;
        }
        
    </style>
</head>
<body>
    <h2 style="border-bottom: dashed; background-color: azure;">Terrain Editing App | 
        <select id="saved-grids">
            <option value="">-- Select from saved grids --</option>
            {% for grid in saved_grids %}
                <option value="{{ grid.id }}">{{ grid.name }} ({{ grid.rows }}×{{ grid.cols }})</option>
            {% endfor %}
        </select>
        <button id="load-grid">Load Grid</button>
        <button id="delete-grid" style="background-color: lightsalmon;">Delete</button>
        <span style="font-size: small;"><input type="checkbox" id="save-copy"> Save as copy</span>
        <input type="text" id="grid-name" placeholder="New Grid Name" value="{{ grid_name|default('') }}">
        <button id="save-selection">Save Changes</button>
        <a href="/"> / reset / </a>
    </h2>
    
    <div class="controls"> 
        File: <textarea id="file-name" readonly rows="1" cols="20"></textarea> 
        <button style="font-size: small; background-color: gray;" onclick="copyToClipboard('file-name')">copy</button> Dimension:
        <input type="number" id="grid-rows" class="size-input" min="1" max="64" value="{{ grid_rows|default(8) }}">
        ×
        <input type="number" id="grid-cols" class="size-input" min="1" max="64" value="{{ grid_cols|default(8) }}">
        <button id="create-grid">Create Grid</button>
        <button id="clear-selection">Clear Selection</button>
        <span style="border: dashed; padding: 5px;">
            <button id="single-select" class="active">Single Cell</button>
            <button id="range-select">Range Selection</button> | 
            <button id="add-type-mode" class="active">Add Type</button>
            <button id="remove-type-mode">Remove Type</button>
        </span>
    </div>
    
    <div class="cell-types-container" id="cell-types-list">
        <div class="custom-type-creator">
            <input type="text" id="custom-type-name" placeholder="New Goal Name">
            <input type="color" id="custom-type-color" class="color-picker" value="#3F51B5">
            <button id="add-custom-type">Add custom goal</button>
        </div>
        <div class="cell-type-tag" data-type="obstacle">
            <div class="cell-type-color" style="background-color: #333;"></div>
            <span>Obstacle</span>
        </div>
        <div class="cell-type-tag" data-type="goal-1">
            <div class="cell-type-color" style="background-color: #2196F3;"></div>
            <span>Goal 1</span>
        </div>
        <div class="cell-type-tag" data-type="goal-2">
            <div class="cell-type-color" style="background-color: #FF9800;"></div>
            <span>Goal 2</span>
        </div>
        <div class="cell-type-tag" data-type="goal-3">
            <div class="cell-type-color" style="background-color: #9C27B0;"></div>
            <span>Goal 3</span>
        </div>
        <div class="cell-type-tag" data-type="goal-4">
            <div class="cell-type-color" style="background-color: #E91E63;"></div>
            <span>Goal 4</span>
        </div>
        <div class="cell-type-tag" data-type="goal-5">
            <div class="cell-type-color" style="background-color: #00BCD4;"></div>
            <span>Goal 5</span>
        </div>
        {% if custom_types %}
            {% for type_key, type_info in custom_types.items() %}
                <div class="cell-type-tag" data-type="{{ type_key }}">
                    <div class="cell-type-color" style="background-color: {{ type_info.color }};"></div>
                    <span>{{ type_info.name }}</span>
                    <span class="cell-type-delete">×</span>
                </div>
            {% endfor %}
        {% endif %}
    </div>
    
    <div class="grid-container">
        <div id="grid" class="grid"></div>
    </div>
    
    <script>
        function copyToClipboard(elem) {
            const fileNameElement = document.getElementById(elem);
            fileNameElement.select();
            document.execCommand('copy');
            
            // Visual feedback
            const btn = document.querySelector('.copy-btn');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            
            setTimeout(function() {
                btn.textContent = originalText;
            }, 1500);
        }
        document.addEventListener('DOMContentLoaded', function() {
            const gridContainer = document.getElementById('grid');
            const createGridButton = document.getElementById('create-grid');
            const saveSelectionButton = document.getElementById('save-selection');
            const clearSelectionButton = document.getElementById('clear-selection');
            const gridRowsInput = document.getElementById('grid-rows');
            const gridColsInput = document.getElementById('grid-cols');
            const singleSelectButton = document.getElementById('single-select');
            const rangeSelectButton = document.getElementById('range-select');
            const addTypeModeButton = document.getElementById('add-type-mode');
            const removeTypeModeButton = document.getElementById('remove-type-mode');
            const customTypeNameInput = document.getElementById('custom-type-name');
            const customTypeColorInput = document.getElementById('custom-type-color');
            const addCustomTypeButton = document.getElementById('add-custom-type');
            const cellTypesList = document.getElementById('cell-types-list');
            const savedGridsSelect = document.getElementById('saved-grids');
            const loadGridButton = document.getElementById('load-grid');
            const delGridButton = document.getElementById('delete-grid');
            const gridNameInput = document.getElementById('grid-name');
            const fileName = document.getElementById("file-name");
            
            let selectedCells = [];
            let isRangeSelectionMode = false;
            let isAddTypeMode = true;
            let rangeStart = null;
            let cellTypes = {
                'obstacle': { name: 'Obstacle', color: '#333' },
                'goal-1': { name: 'Goal 1', color: '#2196F3' },
                'goal-2': { name: 'Goal 2', color: '#FF9800' },
                'goal-3': { name: 'Goal 3', color: '#9C27B0' },
                'goal-4': { name: 'Goal 4', color: '#E91E63' },
                'goal-5': { name: 'Goal 5', color: '#00BCD4' }
            };
            
            // Initialize with any custom types from backend
            {% if custom_types %}
                {% for type_key, type_info in custom_types.items() %}
                    cellTypes['{{ type_key }}'] = { 
                        name: '{{ type_info.name }}', 
                        color: '{{ type_info.color }}' 
                    };
                    addCellTypeStyle('{{ type_key }}', '{{ type_info.color }}');
                {% endfor %}
            {% endif %}
            
            let currentCellType = 'obstacle';
            
            // Initialize the grid with default size or loaded size
            createGrid(
                {{ grid_rows|default(8) }}, 
                {{ grid_cols|default(8) }}
            );
            
            // Load any existing cell selections from backend
            {% if selected_cells %}
                loadCellSelections({{ selected_cells|tojson }});
            {% endif %}
            
            // Create grid when button is clicked
            createGridButton.addEventListener('click', function() {
                const rows = parseInt(gridRowsInput.value);
                const cols = parseInt(gridColsInput.value);
                if (rows >= 1 && rows <= 64 && cols >= 1 && cols <= 64) {
                    createGrid(rows, cols);
                } else {
                    alert('Please enter grid dimensions between 1 and 64');
                }
            });
            
            // Toggle selection mode
            singleSelectButton.addEventListener('click', function() {
                isRangeSelectionMode = false;
                singleSelectButton.classList.add('active');
                rangeSelectButton.classList.remove('active');
                rangeStart = null;
            });
            
            rangeSelectButton.addEventListener('click', function() {
                isRangeSelectionMode = true;
                rangeSelectButton.classList.add('active');
                singleSelectButton.classList.remove('active');
                rangeStart = null;
            });
            
            // Toggle type action mode
            addTypeModeButton.addEventListener('click', function() {
                isAddTypeMode = true;
                addTypeModeButton.classList.add('active');
                removeTypeModeButton.classList.remove('active');
            });
            
            removeTypeModeButton.addEventListener('click', function() {
                isAddTypeMode = false;
                removeTypeModeButton.classList.add('active');
                addTypeModeButton.classList.remove('active');
            });
            
            // Load grid button handler
            delGridButton.addEventListener('click', function() {
                const gridId = savedGridsSelect.value;
                if (!gridId) {
                    alert('Please select a grid to delete');
                    return;
                }
                
                fetch(`/delete_grid/${gridId}`, {
                    method: 'POST',
                }).then(response => response.json()).then(data => {
                    if (data.success) {
                        alert('Grid ' + gridId + ' deleted successfully!');
                        savedGridsSelect.remove(savedGridsSelect.selectedIndex)
                        fileName.innerHTML = "";
                    } else {
                        alert('Error deleting grid selection: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while saving.');
                });
            });
            loadGridButton.addEventListener('click', function() {
                const gridId = savedGridsSelect.value;
                if (!gridId) {
                    alert('Please select a grid to load');
                    return;
                }
                
                fetch(`/load_grid/${gridId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Update grid dimensions inputs
                            fileName.innerHTML = "'"+data.grid_id+".json'";
                            gridRowsInput.value = data.grid_rows;
                            gridColsInput.value = data.grid_cols;
                            gridNameInput.value = data.grid_name;
                            
                            // Create new grid with loaded dimensions
                            createGrid(data.grid_rows, data.grid_cols);
                            
                            // Clear existing cell types except defaults
                            document.querySelectorAll('.cell-type-tag').forEach(tag => {
                                if (tag.dataset.type && tag.dataset.type.startsWith('custom-')) {
                                    cellTypesList.removeChild(tag);
                                }
                            });
                            
                            // Reset cell types to defaults
                            cellTypes = {
                                'obstacle': { name: 'Obstacle', color: '#333' },
                                'goal-1': { name: 'Goal 1', color: '#2196F3' },
                                'goal-2': { name: 'Goal 2', color: '#FF9800' },
                                'goal-3': { name: 'Goal 3', color: '#9C27B0' },
                                'goal-4': { name: 'Goal 4', color: '#E91E63' },
                                'goal-5': { name: 'Goal 5', color: '#00BCD4' }
                            };
                            
                            // Add custom cell types from loaded data
                            if (data.cell_types) {
                                for (const [typeKey, typeInfo] of Object.entries(data.cell_types)) {
                                    if (typeKey.startsWith('custom-')) {
                                        cellTypes[typeKey] = {
                                            name: typeInfo.name,
                                            color: typeInfo.color
                                        };
                                        
                                        // Add to UI
                                        addCellTypeTag(typeKey, typeInfo.name, typeInfo.color);
                                        addCellTypeStyle(typeKey, typeInfo.color);
                                    }
                                }
                            }
                            
                            // Load cell selections
                            loadCellSelections(data.selected_cells);
                        } else {
                            alert('Error loading grid: ' + data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while loading the grid.');
                    });
            });
            
            // Load cell selections into the grid
            function loadCellSelections(cells) {
                selectedCells = [];
                
                // Clear existing selections
                document.querySelectorAll('.cell').forEach(cell => {
                    Object.keys(cellTypes).forEach(typeKey => {
                        cell.classList.remove(typeKey);
                    });
                    
                    const labelsContainer = cell.querySelector('.cell-labels');
                    if (labelsContainer) {
                        labelsContainer.innerHTML = '';
                    }
                });
                
                // Apply loaded selections
                cells.forEach(cellData => {
                    const cell = document.querySelector(`.cell[data-row="${cellData.row}"][data-col="${cellData.col}"]`);
                    if (cell) {
                        addCellType(cell, cellData.row, cellData.col, cellData.type);
                    }
                });
            }
            
            // Add custom cell type
            addCustomTypeButton.addEventListener('click', function() {
                const typeName = customTypeNameInput.value.trim();
                const typeColor = customTypeColorInput.value;
                
                if (typeName === '') {
                    alert('Please enter a type name');
                    return;
                }
                
                // Create a valid key for the type
                const typeKey = 'custom-' + typeName.toLowerCase().replace(/\s+/g, '-');
                
                // Check if this type already exists
                if (cellTypes[typeKey]) {
                    alert('A type with this name already exists');
                    return;
                }
                
                // Add to cell types
                cellTypes[typeKey] = {
                    name: typeName,
                    color: typeColor
                };
                
                // Add to cell types list
                addCellTypeTag(typeKey, typeName, typeColor);
                
                // Clear input
                customTypeNameInput.value = '';
                
                // Add style for the new type
                addCellTypeStyle(typeKey, typeColor);
            });
            
            // Add style for a new cell type
            function addCellTypeStyle(typeKey, color) {
                const style = document.createElement('style');
                style.textContent = `
                    .cell.${typeKey} {
                        background-color: ${color};
                        color: white;
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Add a cell type tag to the UI
            function addCellTypeTag(typeKey, name, color) {
                const tagElement = document.createElement('div');
                tagElement.className = 'cell-type-tag';
                tagElement.dataset.type = typeKey;
                
                const colorIndicator = document.createElement('div');
                colorIndicator.className = 'cell-type-color';
                colorIndicator.style.backgroundColor = color;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                
                const deleteButton = document.createElement('span');
                deleteButton.className = 'cell-type-delete';
                deleteButton.textContent = '×';
                deleteButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (confirm(`Delete type "${name}"?`)) {
                        // Remove the type from all cells
                        removeCellTypeFromAllCells(typeKey);
                        
                        // Remove from types list
                        delete cellTypes[typeKey];
                        
                        // Remove the tag from UI
                        cellTypesList.removeChild(tagElement);
                        
                        // If this was the selected type, select the default
                        if (currentCellType === typeKey) {
                            selectCellType('obstacle');
                        }
                    }
                });
                
                tagElement.appendChild(colorIndicator);
                tagElement.appendChild(nameSpan);
                tagElement.appendChild(deleteButton);
                
                // Handle click to select this type
                tagElement.addEventListener('click', function() {
                    selectCellType(typeKey);
                });
                
                cellTypesList.appendChild(tagElement);
            }
            
            // Select a cell type
            function selectCellType(typeKey) {
                currentCellType = typeKey;
                
                // Update UI
                document.querySelectorAll('.cell-type-tag').forEach(tag => {
                    if (tag.dataset.type === typeKey) {
                        tag.classList.add('active');
                    } else {
                        tag.classList.remove('active');
                    }
                });
            }
            
            // Initialize cell type selection
            document.querySelectorAll('.cell-type-tag').forEach(tag => {
                tag.addEventListener('click', function() {
                    selectCellType(this.dataset.type);
                });
            });
            
            // Remove a cell type from all cells
            function removeCellTypeFromAllCells(typeKey) {
                // Remove class from all cells
                document.querySelectorAll(`.cell.${typeKey}`).forEach(cell => {
                    cell.classList.remove(typeKey);
                });
                
                // Remove from selected cells data
                selectedCells = selectedCells.filter(cell => cell.type !== typeKey);
                
                // Remove labels
                document.querySelectorAll('.cell').forEach(cell => {
                    updateCellLabels(cell);
                });
            }
            
            // Create a new grid with given size
            function createGrid(rows, cols) {
                // Clear existing grid
                gridContainer.innerHTML = '';
                selectedCells = [];
                
                // Set grid template
                gridContainer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                gridContainer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
                
                // Create cells
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.title = `r=${row},c=${col}`;
                        
                        // Create container for labels
                        const labelsContainer = document.createElement('div');
                        labelsContainer.className = 'cell-labels';
                        cell.appendChild(labelsContainer);
                        
                        // Handle cell click event
                        cell.addEventListener('click', function() {
                            const cellRow = parseInt(this.dataset.row);
                            const cellCol = parseInt(this.dataset.col);
                            
                            if (isRangeSelectionMode) {
                                // Range selection mode
                                if (rangeStart === null) {
                                    // First click - set start point
                                    rangeStart = { row: cellRow, col: cellCol };
                                    this.classList.add('range-start');
                                } else {
                                    // Second click - select the range
                                    const startRow = Math.min(rangeStart.row, cellRow);
                                    const endRow = Math.max(rangeStart.row, cellRow);
                                    const startCol = Math.min(rangeStart.col, cellCol);
                                    const endCol = Math.max(rangeStart.col, cellCol);
                                    
                                    // Apply selection to all cells in range
                                    selectRange(startRow, endRow, startCol, endCol);
                                    
                                    // Remove range start indicator
                                    document.querySelectorAll('.cell.range-start').forEach(cell => {
                                        cell.classList.remove('range-start');
                                    });
                                    
                                    // Reset for next range selection
                                    rangeStart = null;
                                }
                            } else {
                                // Single selection mode
                                handleCellSelection(this, cellRow, cellCol);
                            }
                        });
                        
                        gridContainer.appendChild(cell);
                    }
                }
            }
            
            // Handle cell selection based on current mode
            function handleCellSelection(cellElement, row, col) {
                if (isAddTypeMode) {
                    addCellType(cellElement, row, col, currentCellType);
                } else {
                    removeCellType(cellElement, row, col, currentCellType);
                }
            }
            
            // Add a type to a cell
            function addCellType(cellElement, row, col, typeKey) {
                // Check if this cell already has this type
                const existingIndex = selectedCells.findIndex(c => 
                    c.row === row && c.col === col && c.type === typeKey);
                
                if (existingIndex < 0) {
                    // Add class to cell
                    cellElement.classList.add(typeKey);
                    
                    // Add to selected cells
                    selectedCells.push({
                        row: row,
                        col: col,
                        type: typeKey
                    });
                    
                    // Update labels
                    updateCellLabels(cellElement);
                }
            }
            
            // Remove a type from a cell
            function removeCellType(cellElement, row, col, typeKey) {
                // Find this cell type
                const existingIndex = selectedCells.findIndex(c => 
                    c.row === row && c.col === col && c.type === typeKey);
                
                if (existingIndex >= 0) {
                    // Remove class from cell
                    cellElement.classList.remove(typeKey);
                    
                    // Remove from selected cells
                    selectedCells.splice(existingIndex, 1);
                    
                    // Update labels
                    updateCellLabels(cellElement);
                }
            }
            
            // Update labels on a cell
            function updateCellLabels(cellElement) {
                const row = parseInt(cellElement.dataset.row);
                const col = parseInt(cellElement.dataset.col);
                const labelsContainer = cellElement.querySelector('.cell-labels');
                
                // Clear existing labels
                labelsContainer.innerHTML = '';
                
                // Get all types for this cell
                const cellTypesData = selectedCells.filter(c => c.row === row && c.col === col);
                
                // Create a label for each type
                cellTypesData.forEach(cellData => {
                    const typeInfo = cellTypes[cellData.type];
                    let typeIndex = Object.keys(cellTypes).indexOf(cellData.type);
                    if (typeIndex > 5) {
                        typeIndex = typeInfo.name.substr(0, 2);
                    }
                    if (typeInfo) {
                        const label = document.createElement('span');
                        label.className = 'cell-label';
                        label.textContent = typeIndex;
                        label.style.backgroundColor = typeInfo.color;
                        label.style.color = getContrastColor(typeInfo.color);
                        labelsContainer.appendChild(label);
                    }
                });
            }
            
            // Get a contrasting text color (black or white) based on background color
            function getContrastColor(hexColor) {
                // Convert hex to RGB
                const r = parseInt(hexColor.substr(1, 2), 16);
                const g = parseInt(hexColor.substr(3, 2), 16);
                const b = parseInt(hexColor.substr(5, 2), 16);
                
                // Calculate luminance
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                // Return black for light colors, white for dark colors
                return luminance > 0.5 ? '#000000' : '#FFFFFF';
            }
            
            // Select a range of cells
            function selectRange(startRow, endRow, startCol, endCol) {
                // Apply selection to each cell in the range
                for (let row = startRow; row <= endRow; row++) {
                    for (let col = startCol; col <= endCol; col++) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            if (isAddTypeMode) {
                                addCellType(cell, row, col, currentCellType);
                            } else {
                                removeCellType(cell, row, col, currentCellType);
                            }
                        }
                    }
                }
            }
            
            // Save selection to the backend
            saveSelectionButton.addEventListener('click', function() {
                const formData = new FormData();
                formData.append('grid_rows', gridRowsInput.value);
                formData.append('grid_cols', gridColsInput.value);
                formData.append('grid_name', gridNameInput.value || 'Untitled Grid');
                formData.append('copy', document.getElementById("save-copy").checked);
                formData.append('grid_id', savedGridsSelect.value);
                formData.append('selected_cells', JSON.stringify(selectedCells));
                formData.append('cell_types', JSON.stringify(cellTypes));
                
                fetch('/save_grid', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Grid selection saved successfully!');
                        if (data.grid_id) {
                            // If this is a new grid, add it to the dropdown
                            const entry = savedGridsSelect.querySelector(`option[value="${data.grid_id}"]`);
                            if (!entry) {
                                const option = document.createElement('option');
                                option.value = data.grid_id;
                                option.textContent = `${gridNameInput.value || 'Untitled Grid'} (${gridRowsInput.value}×${gridColsInput.value})`;
                                savedGridsSelect.appendChild(option);
                                fileName.innerHTML = "'"+data.grid_id+".json'";
                            } else {
                                entry.innerHTML = data.grid_name + " (" + data.grid_rows + "×" +data.grid_cols + ")";
                            }
                        }
                        if (data.redirect) {
                            window.location.href = data.redirect;
                        }
                    } else {
                        alert('Error saving grid selection: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while saving.');
                });
            });
            
            // Clear all selections
            clearSelectionButton.addEventListener('click', function() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    // Remove all type classes
                    Object.keys(cellTypes).forEach(typeKey => {
                        cell.classList.remove(typeKey);
                    });
                    
                    // Clear labels
                    const labelsContainer = cell.querySelector('.cell-labels');
                    if (labelsContainer) {
                        labelsContainer.innerHTML = '';
                    }
                });
                
                selectedCells = [];
                rangeStart = null;
            });
            
            // Select obstacle type by default
            selectCellType('obstacle');
        });
    </script>
</body>
</html>